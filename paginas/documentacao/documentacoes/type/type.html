<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!--titulo-->
    <title>Pcpropr</title>
    <!--link css-->
    <link rel="stylesheet" href="/paginas/documentacao/documentacoes/geral.css"/>
    <!--link da logo da barra do navegador-->
    <link rel="shortcut icon" href="/img/logo barra superior.png" type="image/x-icon"/>
    <!--importa√ß√£o do google fonts-->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900&display=swap" rel="stylesheet"/>
  </head>

  <body>
    <!--logo-->
    <header class="site-header">
      <div class="header-inner">
        <div class="logo-container">

          <a href=""><img src="/img/logo barra menu.png" alt="logo" class="logotipo"/></a>
          <a href="/index.html" class="site-nav"></a>

        </div>
        <!--bot√µes do menu-->
        <nav class="site-nav">
          <ul>
            <li><a href="/index.html">In√≠cio</a></li>
            <li><a href="/paginas/sobre/index.html">Sobre</a></li>
            <li><a href="/paginas/contato/index.html">Contato</a></li>
            <li><a href="/paginas/documentacao/index.html">Documenta√ß√µes</a></li>
          </ul>
        </nav>
      </div>
    </header>

    <!-- Conte√∫do Principal -->
     <section>
    <main class="container">
        <section class="content-section">
            <section>
            <h1>Documenta√ß√£o do TypeScript</h1>

    <h2>1. Fundamentos do TypeScript</h2>
    <ul>
        <li>Superset do JavaScript</li>
        <li>Tipagem est√°tica opcional</li>
        <li>Transpila√ß√£o para JavaScript</li>
    </ul>

    <h2>2. Tipos Primitivos</h2>
    <ul>
        <li>string, number, boolean</li>
        <li>null e undefined</li>
        <li>any (evitar sempre que poss√≠vel)</li>
        <li>unknown (alternativa mais segura ao any)</li>
        <li>void (usado em fun√ß√µes que n√£o retornam valor)</li>
        <li>never (para fun√ß√µes que nunca retornam)</li>
    </ul>

    <h2>3. Tipos Avan√ßados</h2>
    <ul>
        <li><strong>Arrays e Tuplas</strong> (string[], [number, string])</li>
        <li><strong>Enums</strong> (define conjuntos de valores fixos)</li>
        <li><strong>Union & Intersection Types</strong> (string | number, A & B)</li>
        <li><strong>Type Aliases e Interfaces</strong> (type vs interface)</li>
        <li><strong>Generics</strong> (Array&lt;T&gt;, Promise&lt;T&gt;)</li>
        <li><strong>Type Assertions</strong> (as, &lt;Type&gt;value)</li>
    </ul>

    <h2>4. Orienta√ß√£o a Objetos</h2>
    <ul>
        <li>Classes e Modificadores (public, private, protected)</li>
        <li>Heran√ßa e Implementa√ß√£o de Interfaces</li>
        <li>M√©todos e Propriedades Est√°ticas</li>
        <li>Getters e Setters</li>
    </ul>

    <h2>5. Manipula√ß√£o de C√≥digo</h2>
    <ul>
        <li>Namespaces e M√≥dulos (import/export)</li>
        <li>Decorators (para metaprograma√ß√£o)</li>
        <li>Tipagem Estrutural</li>
    </ul>

    <h2>6. Ferramentas e Configura√ß√£o</h2>
    <ul>
        <li><strong>Arquivo tsconfig.json</strong> (configura√ß√£o do compilador)</li>
        <li><strong>Compilador tsc</strong> (TypeScript Compiler)</li>
        <li><strong>Linting e Formata√ß√£o</strong> (ESLint, Prettier)</li>
    </ul>

    <h2>7. Integra√ß√£o com Frameworks</h2>
    <ul>
        <li><strong>Node.js</strong> (tipagem com @types/node)</li>
        <li><strong>React</strong> (tsx, React.FC&lt;T&gt;)</li>
        <li><strong>Angular</strong> (forte integra√ß√£o com TypeScript)</li>
    </ul>

    <h2>8. Boas Pr√°ticas</h2>
    <ul>
        <li>Evitar any sempre que poss√≠vel</li>
        <li>Usar interfaces para contratos de dados</li>
        <li>Preferir readonly para propriedades imut√°veis</li>
        <li>Documenta√ß√£o com JSDoc</li>
    </ul>
</section>
<hr>
<br>
<br>

    <h1>1. Fundamentos do TypeScript</h1>

<p>TypeScript √© uma linguagem que expande o JavaScript adicionando tipagem est√°tica e recursos avan√ßados. Ele foi criado pela Microsoft e se tornou muito popular para desenvolvimento web, especialmente em projetos grandes.</p>

<p>Agora, vamos entender os tr√™s conceitos fundamentais do TypeScript:</p>

<hr>

<h2>1.1 Superset do JavaScript</h2>

<p><strong>O que significa ser um superset?</strong></p>
<p>TypeScript √© um <em>superset</em> de JavaScript, o que significa que <strong>todo c√≥digo JavaScript v√°lido tamb√©m √© v√°lido em TypeScript</strong>. Isso facilita a ado√ß√£o da linguagem, pois voc√™ pode come√ßar usando JavaScript puro e, aos poucos, adicionar funcionalidades do TypeScript.</p>

<p><strong>Exemplo:</strong> C√≥digo JavaScript puro v√°lido em TypeScript:</p>
<pre><code>
function soma(a, b) {
return a + b;
}
console.log(soma(2, 3)); // 5
</code></pre>
<p>Esse c√≥digo funciona tanto em JavaScript quanto em TypeScript.</p>

<p><strong>Expans√£o do JavaScript:</strong></p>
<p>TypeScript adiciona novos recursos que o JavaScript n√£o tem, como:</p>
<ul>
    <li><strong>Tipagem est√°tica</strong> (explicada abaixo)</li>
    <li><strong>Interfaces e Generics</strong></li>
    <li><strong>Modificadores de acesso</strong> (private, protected, public)</li>
    <li><strong>Decorators</strong></li>
</ul>
<p>Esses recursos ajudam a melhorar a seguran√ßa e a organiza√ß√£o do c√≥digo.</p>

<hr>

<h2>1.2 Tipagem Est√°tica Opcional</h2>

<p><strong>O que √© tipagem est√°tica?</strong></p>
<p>Em JavaScript, os tipos das vari√°veis s√£o din√¢micos, ou seja, podem mudar em tempo de execu√ß√£o:</p>
<pre><code>
let x = "Ol√°";
x = 10; // JavaScript permite isso, mas pode causar erros inesperados
</code></pre>
<p>J√° em TypeScript, podemos <strong>definir tipos explicitamente</strong>, garantindo que as vari√°veis sempre contenham valores esperados:</p>
<pre><code>
let x: string = "Ol√°";
x = 10; // Erro: Type 'number' is not assignable to type 'string'
</code></pre>

<p><strong>Benef√≠cios da tipagem est√°tica:</strong></p>
<ul>
    <li>Evita erros em tempo de execu√ß√£o</li>
    <li>Facilita a refatora√ß√£o do c√≥digo</li>
    <li>Melhora a legibilidade e a manuten√ß√£o</li>
    <li>Ajuda ferramentas como VS Code a oferecer sugest√µes inteligentes (IntelliSense)</li>
</ul>

<p><strong>Tipagem opcional:</strong></p>
<p>TypeScript n√£o obriga voc√™ a tipar tudo. Se voc√™ n√£o especificar um tipo, ele tentar√° inferir automaticamente:</p>
<pre><code>
let nome = "Maria"; // TypeScript entende que √© uma string
nome = 42; // Erro: Type 'number' is not assignable to type 'string'
</code></pre>

<hr>

<h2>1.3 Transpila√ß√£o para JavaScript</h2>

<p><strong>Por que transpila√ß√£o?</strong></p>
<p>Os navegadores e runtimes como Node.js n√£o entendem TypeScript diretamente. Por isso, o c√≥digo TypeScript precisa ser <strong>transpilado</strong> para JavaScript antes de ser executado.</p>

<p><strong>Como funciona a transpila√ß√£o?</strong></p>
<p>O TypeScript Compiler (tsc) converte o c√≥digo TypeScript para JavaScript puro:</p>

<p><strong>C√≥digo TypeScript:</strong></p>
<pre><code>
const mensagem: string = "Ol√°, TypeScript!";
console.log(mensagem);
</code></pre>

<p><strong>C√≥digo JavaScript gerado ap√≥s a transpila√ß√£o:</strong></p>
<pre><code>
const mensagem = "Ol√°, TypeScript!";
console.log(mensagem);
</code></pre>
<p>Perceba que os tipos (string) desaparecem no JavaScript final. Isso acontece porque os tipos existem apenas no tempo de desenvolvimento, ajudando o programador, mas n√£o impactam o c√≥digo final.</p>

<p><strong>Configura√ß√£o da transpila√ß√£o (tsconfig.json):</strong></p>
<p>Podemos personalizar como o TypeScript √© convertido para JavaScript atrav√©s do arquivo tsconfig.json. Um exemplo b√°sico:</p>
<pre><code>
{
"compilerOptions": {
"target": "ES6",  // Define a vers√£o do JavaScript gerado
"outDir": "dist", // Pasta de sa√≠da do c√≥digo JavaScript
"strict": true    // Habilita verifica√ß√µes rigorosas de tipo
}
}
</code></pre>
<p>Isso garante que o c√≥digo gerado seja compat√≠vel com a vers√£o desejada do JavaScript e siga regras de tipagem mais seguras.</p>

<h2>Conclus√£o</h2>
<p>TypeScript √© um superset do JavaScript, adicionando <strong>tipagem est√°tica opcional</strong> para evitar erros e melhorar a produtividade. Como os navegadores n√£o entendem TypeScript, ele precisa ser <strong>transpilado para JavaScript</strong> antes de ser executado.</p>
<hr>
<br>
<h1>2. Tipos Primitivos no TypeScript</h1>

<p>Os tipos primitivos s√£o os tipos b√°sicos de dados que representam valores simples. Eles s√£o fundamentais para garantir seguran√ßa no c√≥digo e evitar erros inesperados.</p>

<hr>

<h2>2.1 string, number e boolean</h2>

<p><strong>string</strong>: Representa textos e cadeias de caracteres.</p>
<pre><code>
let nome: string = "Jo√£o";
let mensagem: string = `Ol√°, ${nome}!`; // Template string
</code></pre>
<p>‚ûú Se tentarmos atribuir outro tipo, TypeScript gera um erro:</p>
<pre><code>
nome = 123; // Erro: Type 'number' is not assignable to type 'string'
</code></pre>

<p><strong>number</strong>: Representa valores num√©ricos (inteiros ou decimais).</p>
<pre><code>
let idade: number = 30;
let temperatura: number = 36.5;
let hexadecimal: number = 0xff; // Suporte a hexadecimal
</code></pre>
<p>‚ûú O TypeScript aceita <strong>inteiros, decimais, hexadecimais e bin√°rios</strong>.</p>

<p><strong>boolean</strong>: Representa valores true ou false.</p>
<pre><code>
let ativo: boolean = true;
ativo = false;
</code></pre>

<hr>

<h2>2.2 null e undefined</h2>

<p>O TypeScript trata null e undefined de forma especial.</p>

<p><strong><code>undefined</code></strong>: Representa uma vari√°vel que foi declarada, mas n√£o recebeu valor.</p>
<pre><code>
let x: undefined;
console.log(x); // undefined
</code></pre>

<p><strong><code>null</code></strong>: Representa a aus√™ncia intencional de um valor.</p>
<pre><code>
let y: null = null;
</code></pre>

<p>Por padr√£o, o TypeScript pode impedir que vari√°veis tenham <code>null</code> ou <code>undefined</code> a menos que seja explicitamente permitido:</p>
<pre><code>
let nome: string = null; // Erro se o modo "strictNullChecks" estiver ativado!
</code></pre>

<p>Se quisermos permitir <code>null</code>, podemos usar <strong>Union Types</strong>:</p>
<pre><code>
let nome: string | null = "Maria";
nome = null; // Agora isso √© permitido
</code></pre>

<hr>

<h2>2.3 <code>any</code> (evitar sempre que poss√≠vel!)</h2>

<p>O tipo <code>any</code> desativa a verifica√ß√£o de tipos, permitindo que a vari√°vel contenha qualquer valor.</p>
<pre><code>
let valor: any = "Ol√°";
valor = 42;
valor = true;
</code></pre>

<p><strong>Problema com <code>any</code>:</strong> Ele elimina as vantagens do TypeScript, pois o c√≥digo perde seguran√ßa e previsibilidade.</p>

<p><strong>Quando usar <code>any</code>?</strong></p>
<ul>
    <li>Quando n√£o sabemos o tipo exato dos dados (por exemplo, dados vindos de uma API desconhecida).</li>
    <li>Quando migramos c√≥digo JavaScript para TypeScript e ainda n√£o adicionamos tipagem correta.</li>
</ul>

<p><strong>Alternativa ao <code>any</code>: <code>unknown</code> (veja abaixo üëá)</strong></p>

<hr>

<h2>2.4 <code>unknown</code> (alternativa mais segura ao <code>any</code>)</h2>

<p><code>unknown</code> √© um tipo semelhante ao <code>any</code>, mas com <strong>mais seguran√ßa</strong>.</p>
<pre><code>
let dado: unknown;

dado = "Ol√°";
dado = 42;
dado = true;
</code></pre>

<p>A diferen√ßa √© que <strong>n√£o podemos acessar propriedades ou chamar m√©todos sem verificar o tipo primeiro</strong>:</p>
<pre><code>
dado.toUpperCase(); // Erro: Object is of type 'unknown'
</code></pre>

<p>Para usar um valor <code>unknown</code>, precisamos primeiro fazer uma verifica√ß√£o de tipo:</p>
<pre><code>
if (typeof dado === "string") {
console.log(dado.toUpperCase()); // Agora funciona!
}
</code></pre>

<p>‚úÖ <strong>Melhor pr√°tica</strong>: Prefira <code>unknown</code> em vez de <code>any</code>, pois obriga voc√™ a validar os dados antes de us√°-los.</p>

<hr>

<h2>2.5 <code>void</code> (para fun√ß√µes que n√£o retornam valor)</h2>

<p>O tipo <code>void</code> √© usado para indicar que uma fun√ß√£o <strong>n√£o retorna um valor</strong>.</p>
<pre><code>
function logMensagem(mensagem: string): void {
console.log(mensagem);
}
</code></pre>

<ul>
    <li>Se tentarmos retornar algo de uma fun√ß√£o <code>void</code>, TypeScript gera um erro:
        <pre><code>
function erro(): void {
return "Erro!"; // ‚ùå Erro: Type 'string' is not assignable to type 'void'
}
        </code></pre>
    </li>
    <li>O <code>void</code> tamb√©m pode ser usado em vari√°veis, mas raramente √© √∫til:
        <pre><code>
let resultado: void = undefined; // Permitido, mas pouco pr√°tico
        </code></pre>
    </li>
</ul>

<hr>

<h2>2.6 <code>never</code> (para fun√ß√µes que nunca retornam)</h2>

<p>O tipo <code>never</code> √© usado quando <strong>uma fun√ß√£o nunca retorna um valor</strong> porque ela gera um erro ou entra em um loop infinito.</p>

<h3>Exemplo 1: Fun√ß√£o que lan√ßa um erro</h3>
<pre><code>
function erro(mensagem: string): never {
throw new Error(mensagem);
}
</code></pre>
<p>Essa fun√ß√£o <strong>nunca retorna nada</strong> porque <strong>interrompe a execu√ß√£o do programa</strong>.</p>

<h3>Exemplo 2: Loop infinito</h3>
<pre><code>
function loopInfinito(): never {
while (true) {
console.log("Executando...");
}
}
</code></pre>
<p>Como a fun√ß√£o <strong>nunca termina</strong>, seu retorno √© <code>never</code>.</p>

<p>‚úÖ <strong>Quando usar <code>never</code>?</strong></p>
<ul>
    <li>Em fun√ß√µes que <strong>sempre lan√ßam exce√ß√µes</strong>.</li>
    <li>Em fun√ß√µes que <strong>nunca alcan√ßam um ponto final de execu√ß√£o</strong>.</li>
</ul>

<hr>

<h2>Resumo</h2>

<table>
    <thead>
        <tr>
            <th>Tipo</th>
            <th>Descri√ß√£o</th>
            <th>Exemplo</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>string</code></td>
            <td>Texto (cadeia de caracteres)</td>
            <td><code>"Hello"</code></td>
        </tr>
        <tr>
            <td><code>number</code></td>
            <td>N√∫meros inteiros e decimais</td>
            <td><code>42</code>, <code>3.14</code></td>
        </tr>
        <tr>
            <td><code>boolean</code></td>
            <td>Valores l√≥gicos</td>
            <td><code>true</code>, <code>false</code></td>
        </tr>
        <tr>
            <td><code>null</code></td>
            <td>Aus√™ncia intencional de valor</td>
            <td><code>null</code></td>
        </tr>
        <tr>
            <td><code>undefined</code></td>
            <td>Vari√°vel sem valor atribu√≠do</td>
            <td><code>undefined</code></td>
        </tr>
        <tr>
            <td><code>any</code></td>
            <td>Pode conter qualquer valor (evitar)</td>
            <td><code>"texto"</code>, <code>42</code>, <code>true</code></td>
        </tr>
        <tr>
            <td><code>unknown</code></td>
            <td>Tipo desconhecido, exige verifica√ß√£o antes do uso</td>
            <td><code>"string"</code>, <code>42</code>, <code>true</code> (mas com seguran√ßa)</td>
        </tr>
        <tr>
            <td><code>void</code></td>
            <td>Fun√ß√£o sem retorno</td>
            <td><code>function log(): void {}</code></td>
        </tr>
        <tr>
            <td><code>never</code></td>
            <td>Fun√ß√£o que nunca retorna</td>
            <td><code>throw new Error("Erro")</code></td>
        </tr>
    </tbody>
</table>

<hr>

<h2>Conclus√£o</h2>

<ul>
    <li><strong>Use <code>string</code>, <code>number</code> e <code>boolean</code> sempre que poss√≠vel.</strong></li>
    <li><strong>Evite <code>any</code></strong> e prefira <code>unknown</code> quando o tipo n√£o for conhecido.</li>
    <li><strong>Use <code>void</code></strong> para fun√ß√µes sem retorno.</li>
    <li><strong>Use <code>never</code></strong> para fun√ß√µes que nunca retornam um valor v√°lido.</li>
</ul>

<p>Isso garante c√≥digo mais seguro, leg√≠vel e f√°cil de manter! üöÄ</p>

<h1>3. Tipos Avan√ßados no TypeScript</h1>

    <p>O TypeScript fornece tipos mais sofisticados para aumentar a flexibilidade e seguran√ßa do c√≥digo. Vamos explorar cada um deles.</p>

    <hr>

    <h2>3.1 Arrays e Tuplas</h2>

    <h3>Arrays</h3>
    <p>No TypeScript, podemos definir <strong>arrays tipados</strong> para garantir que todos os elementos tenham um tipo espec√≠fico.</p>
    <pre><code>
let numeros: number[] = [1, 2, 3, 4, 5]; // Apenas n√∫meros
let nomes: string[] = ["Alice", "Bob", "Carlos"]; // Apenas strings
    </code></pre>
    <p>Outra forma de definir arrays √© usando <strong>Generics (<code>Array&lt;T&gt;</code>)</strong>:</p>
    <pre><code>
let numeros: Array&lt;number&gt; = [10, 20, 30]; // Equivalente a number[]
    </code></pre>
    <p>üìå <strong>Observa√ß√£o:</strong> O TypeScript impede opera√ß√µes inv√°lidas em arrays tipados:</p>
    <pre><code>
numeros.push("Texto"); // Erro: Type 'string' is not assignable to type 'number'
    </code></pre>

    <h3>Tuplas</h3>
    <p>Tuplas s√£o um tipo especial de array com <strong>um n√∫mero fixo de elementos e tipos espec√≠ficos para cada posi√ß√£o</strong>.</p>
    <pre><code>
let pessoa: [string, number] = ["Alice", 30];
    </code></pre>
    <p>üìå A diferen√ßa entre arrays e tuplas √© que <strong>tuplas t√™m uma estrutura r√≠gida</strong>, ent√£o a ordem e os tipos dos elementos devem ser seguidos.</p>
    <pre><code>
pessoa = [30, "Alice"]; // Erro: Type 'number' is not assignable to type 'string'
    </code></pre>
    <p>As tuplas tamb√©m podem ter elementos opcionais e valores vari√°veis:</p>
    <pre><code>
let usuario: [number, string, boolean?] = [1, "Carlos"]; // O boolean √© opcional
usuario = [2, "Maria", true]; // Tamb√©m v√°lido
    </code></pre>

    <hr>

    <h2>3.2 Enums</h2>
    <p>Enums s√£o usados para definir um conjunto de valores fixos e nomeados, tornando o c√≥digo mais leg√≠vel.</p>
    <pre><code>
enum StatusPedido {
  Pendente,
  Enviado,
  Entregue
}

let statusAtual: StatusPedido = StatusPedido.Enviado;
console.log(statusAtual); // 1 (os valores padr√£o s√£o n√∫meros, come√ßando em 0)
    </code></pre>
    <p>Podemos atribuir valores espec√≠ficos:</p>
    <pre><code>
enum Status {
  Pendente = "PENDENTE",
  Enviado = "ENVIADO",
  Entregue = "ENTREGUE"
}

let pedido: Status = Status.Entregue;
console.log(pedido); // "ENTREGUE"
    </code></pre>
    <p>üìå <strong>Boas pr√°ticas:</strong></p>
    <ul>
        <li><strong>Use strings em enums</strong> para evitar problemas com valores num√©ricos inesperados.</li>
        <li><strong>Evite enums quando poss√≠vel</strong> ‚Äì prefira <code>const</code> com objetos.</li>
    </ul>
    <p>Exemplo alternativo sem <code>enum</code>:</p>
    <pre><code>
const StatusPedido = {
  Pendente: "PENDENTE",
  Enviado: "ENVIADO",
  Entregue: "ENTREGUE"
} as const;

let pedido: keyof typeof StatusPedido = "Pendente";
    </code></pre>

    <hr>

    <h2>3.3 Union & Intersection Types</h2>

    <h3>Union Types (<code>|</code>)</h3>
    <p>Permitem que uma vari√°vel aceite <strong>mais de um tipo</strong>.</p>
    <pre><code>
let idade: number | string;
idade = 25;
idade = "25 anos"; // Ambos s√£o v√°lidos
    </code></pre>
    <p>√ötil para tratar valores din√¢micos, como entrada de usu√°rios.</p>
    <pre><code>
function mostrarId(id: number | string) {
  console.log(`ID: ${id}`);
}
mostrarId(123);
mostrarId("ABC123");
    </code></pre>
    <p>üìå <strong>Verifica√ß√£o de tipo necess√°ria</strong></p>
    <pre><code>
function processar(valor: number | string) {
  if (typeof valor === "string") {
    console.log(valor.toUpperCase());
  } else {
    console.log(valor.toFixed(2));
  }
}
    </code></pre>

    <h3>Intersection Types (<code>&</code>)</h3>
    <p>Permitem combinar m√∫ltiplos tipos.</p>
    <pre><code>
type Pessoa = { nome: string };
type Funcionario = { cargo: string };

type Empregado = Pessoa & Funcionario;

let emp: Empregado = { nome: "Jo√£o", cargo: "Desenvolvedor" };
    </code></pre>
    <p>üìå <strong>Uso comum:</strong> Para compor objetos complexos e heran√ßa de tipos.</p>

    <hr>

    <h2>3.4 Type Aliases vs Interfaces</h2>

    <h3>Type Aliases (<code>type</code>)</h3>
    <p>Permitem criar <strong>nomes personalizados</strong> para tipos existentes.</p>
    <pre><code>
type ID = string | number;
let userId: ID = 123;
    </code></pre>

    <h3>Interfaces (<code>interface</code>)</h3>
    <p>Definem a <strong>estrutura de objetos</strong>.</p>
    <pre><code>
interface Usuario {
  nome: string;
  idade: number;
}

let user: Usuario = { nome: "Carlos", idade: 28 };
    </code></pre>

    <p>üìå <strong>Diferen√ßas entre <code>type</code> e <code>interface</code>:</strong></p>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th><code>type</code></th>
                <th><code>interface</code></th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Uso para objetos</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
            </tr>
            <tr>
                <td>Uso para primitivos (<code>string</code>, <code>number</code>)</td>
                <td>‚úÖ</td>
                <td>‚ùå</td>
            </tr>
            <tr>
                <td>Extens√≠vel (<code>extends</code>)</td>
                <td>‚ùå</td>
                <td>‚úÖ</td>
            </tr>
            <tr>
                <td>Combina√ß√£o (<code>&</code>)</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
            </tr>
        </tbody>
    </table>

    <hr>

    <h2>3.5 Generics (<code>&lt;T&gt;</code>)</h2>
    <p>Generics permitem <strong>criar fun√ß√µes e classes reutiliz√°veis</strong> sem definir tipos fixos.</p>

    <h3>Exemplo 1: Fun√ß√£o Gen√©rica</h3>
    <pre><code>
function identidade&lt;T&gt;(valor: T): T {
  return valor;
}

console.log(identidade&lt;string&gt;("Teste"));
console.log(identidade&lt;number&gt;(123));
    </code></pre>
    <p>üìå <strong>Vantagem:</strong> Podemos usar <code>identidade()</code> para qualquer tipo sem perder a seguran√ßa.</p>

    <h3>Exemplo 2: Array Gen√©rico</h3>
    <pre><code>
function primeiroElemento&lt;T&gt;(array: T[]): T {
  return array[0];
}

console.log(primeiroElemento&lt;string&gt;(["a", "b", "c"])); // "a"
console.log(primeiroElemento&lt;number&gt;([1, 2, 3])); // 1
    </code></pre>

    <h3>Exemplo 3: Classe Gen√©rica</h3>
    <pre><code>
class Caixa&lt;T&gt; {
  conteudo: T;
  constructor(conteudo: T) {
    this.conteudo = conteudo;
  }
}

let caixaDeNumeros = new Caixa&lt;number&gt;(100);
let caixaDeTexto = new Caixa&lt;string&gt;("Ol√°");
    </code></pre>
    <p>‚úÖ <strong>Uso comum:</strong></p>
    <ul>
        <li>Trabalhar com arrays de diferentes tipos (<code>Array&lt;T&gt;</code>)</li>
        <li>Criar fun√ß√µes flex√≠veis</li>
        <li>Criar classes reutiliz√°veis</li>
    </ul>

    <hr>

    <h2>3.6 Type Assertions (<code>as</code> e <code>&lt;Type&gt;</code>)</h2>
    <p>Type Assertions permitem informar ao TypeScript que um valor tem um tipo espec√≠fico.</p>
    <pre><code>
let valor: any = "Ol√°, TypeScript!";
let tamanho: number = (valor as string).length;
console.log(tamanho); // 17
    </code></pre>
    <p>üìå <strong>Outro modo:</strong></p>
    <pre><code>
let tamanho2: number = (&lt;string&gt;valor).length;
    </code></pre>
    <p>‚úÖ <strong>Quando usar?</strong></p>
    <ul>
        <li>Quando sabemos que um valor tem um tipo espec√≠fico, mas o TypeScript n√£o consegue inferir.</li>
        <li>Ao trabalhar com o DOM:
            <pre><code>
let input = document.getElementById("meuInput") as HTMLInputElement;
console.log(input.value);
            </code></pre>
        </li>
    </ul>

    <hr>

    <h2>Conclus√£o</h2>

    <h3>Resumo dos conceitos principais</h3>
    <table>
        <thead>
            <tr>
                <th>Tipo Avan√ßado</th>
                <th>Descri√ß√£o</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Arrays & Tuplas</strong></td>
                <td>Estruturas ordenadas de dados</td>
            </tr>
            <tr>
                <td><strong>Enums</strong></td>
                <td>Conjuntos de valores fixos</td>
            </tr>
            <tr>
                <td><strong>Union (<code>|</code>)</strong></td>
                <td>Combina m√∫ltiplos tipos</td>
            </tr>
            <tr>
                <td><strong>Intersection (<code>&</code>)</strong></td>
                <td>Combina m√∫ltiplos tipos</td>
            </tr>
            <tr>
                <td><strong>Type vs Interface</strong></td>
                <td>Criam tipos personalizados</td>
            </tr>
            <tr>
                <td><strong>Generics</strong></td>
                <td>C√≥digo reutiliz√°vel para diferentes tipos</td>
            </tr>
            <tr>
                <td><strong>Type Assertions</strong></td>
                <td>For√ßa a interpreta√ß√£o de um tipo</td>
            </tr>
        </tbody>
    </table>

    <p>Esses conceitos tornam o TypeScript <strong>mais poderoso</strong> e <strong>flex√≠vel</strong>! üöÄ</p>

    <p>A <strong>Orienta√ß√£o a Objetos (OO) no TypeScript</strong> traz mais organiza√ß√£o e reutiliza√ß√£o para o c√≥digo. Vamos explorar <strong>Classes, Modificadores, Heran√ßa, Interfaces, M√©todos Est√°ticos, Getters e Setters</strong> com exemplos pr√°ticos.</p>

    <h1>4. Orienta√ß√£o a Objetos no TypeScript</h1>

    <p>O TypeScript estende os recursos de <strong>classes do JavaScript</strong> adicionando <strong>tipagem est√°tica, modificadores de acesso, heran√ßa e interfaces</strong>.</p>

    <hr>

    <h2>4.1 Classes e Modificadores de Acesso</h2>

    <p>Uma classe √© um modelo para criar objetos. No TypeScript, podemos definir <strong>propriedades e m√©todos</strong> dentro de uma classe.</p>

    <h3>Criando uma Classe</h3>
    <pre><code>
class Pessoa {
  nome: string;
  idade: number;

  constructor(nome: string, idade: number) {
    this.nome = nome;
    this.idade = idade;
  }

  apresentar(): string {
    return `Ol√°, meu nome √© ${this.nome} e tenho ${this.idade} anos.`;
  }
}

const pessoa1 = new Pessoa("Alice", 25);
console.log(pessoa1.apresentar());
    </code></pre>

    <h3>Modificadores de Acesso (<code>public</code>, <code>private</code>, <code>protected</code>)</h3>
    <p>Os <strong>modificadores de acesso</strong> controlam <strong>como as propriedades e m√©todos</strong> podem ser acessados dentro e fora da classe.</p>

    <table>
        <thead>
            <tr>
                <th>Modificador</th>
                <th>Acesso na pr√≥pria classe</th>
                <th>Acesso em subclasses</th>
                <th>Acesso fora da classe</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>public</code> (padr√£o)</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
            </tr>
            <tr>
                <td><code>private</code></td>
                <td>‚úÖ</td>
                <td>‚ùå</td>
                <td>‚ùå</td>
            </tr>
            <tr>
                <td><code>protected</code></td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚ùå</td>
            </tr>
        </tbody>
    </table>

    <h3>Exemplo de Modificadores</h3>
    <pre><code>
class ContaBancaria {
  public titular: string; // Acess√≠vel de qualquer lugar
  private saldo: number; // S√≥ acess√≠vel dentro da classe
  protected tipo: string; // Acess√≠vel na classe e subclasses

  constructor(titular: string, saldoInicial: number, tipo: string) {
    this.titular = titular;
    this.saldo = saldoInicial;
    this.tipo = tipo;
  }

  public depositar(valor: number): void {
    this.saldo += valor;
    console.log(`Dep√≥sito de R$${valor}. Novo saldo: R$${this.saldo}`);
  }

  private exibirSaldo(): void {
    console.log(`Saldo atual: R$${this.saldo}`);
  }
}

const conta = new ContaBancaria("Jo√£o", 1000, "Corrente");
conta.depositar(500);
// conta.saldo = 5000; // ‚ùå Erro: saldo √© privado!
    </code></pre>

    <hr>

    <h2>4.2 Heran√ßa e Implementa√ß√£o de Interfaces</h2>

    <p>A <strong>heran√ßa</strong> permite que uma classe <strong>herde propriedades e m√©todos</strong> de outra.</p>

    <h3>Exemplo de Heran√ßa (<code>extends</code>)</h3>
    <pre><code>
class Animal {
  nome: string;

  constructor(nome: string) {
    this.nome = nome;
  }

  emitirSom(): void {
    console.log("Som gen√©rico de um animal...");
  }
}

class Cachorro extends Animal {
  raca: string;

  constructor(nome: string, raca: string) {
    super(nome);
    this.raca = raca;
  }

  emitirSom(): void {
    console.log("Au Au!"); // Sobrescrevendo m√©todo
  }
}

const dog = new Cachorro("Rex", "Labrador");
dog.emitirSom(); // "Au Au!"
console.log(dog.nome); // "Rex"
    </code></pre>
    <p>üìå <strong>O que acontece aqui?</strong></p>
    <ul>
        <li>A classe <code>Cachorro</code> <strong>herda</strong> a propriedade <code>nome</code> e o m√©todo <code>emitirSom()</code> da classe <code>Animal</code>.</li>
        <li>O m√©todo <code>emitirSom()</code> foi <strong>sobrescrito</strong> (polimorfismo).</li>
        <li>O <code>super(nome)</code> chama o construtor da classe <strong>pai</strong> (<code>Animal</code>).</li>
    </ul>

    <h3>Interfaces (<code>implements</code>)</h3>
    <p>Interfaces definem <strong>um contrato</strong> que uma classe deve seguir.</p>
    <pre><code>
interface IUsuario {
  nome: string;
  idade: number;
  logar(): boolean;
}

class Usuario implements IUsuario {
  nome: string;
  idade: number;

  constructor(nome: string, idade: number) {
    this.nome = nome;
    this.idade = idade;
  }

  logar(): boolean {
    console.log(`${this.nome} est√° logado!`);
    return true;
  }
}

const usuario = new Usuario("Maria", 30);
usuario.logar();
    </code></pre>
    <p>üìå <strong>Quando usar <code>extends</code> e <code>implements</code>?</strong></p>
    <ul>
        <li><code>extends</code>: <strong>Herda</strong> propriedades e m√©todos de uma classe.</li>
        <li><code>implements</code>: <strong>Garante</strong> que uma classe siga um contrato, sem herdar implementa√ß√µes.</li>
    </ul>

    <hr>

    <h2>4.3 M√©todos e Propriedades Est√°ticas (<code>static</code>)</h2>

    <p>Os <strong>m√©todos e propriedades est√°ticas</strong> pertencem √† classe, <strong>n√£o aos objetos</strong>.</p>

    <h3>Exemplo</h3>
    <pre><code>
class Util {
  static versao: string = "1.0";

  static saudacao(): string {
    return "Bem-vindo ao sistema!";
  }
}

console.log(Util.versao); // "1.0"
console.log(Util.saudacao()); // "Bem-vindo ao sistema!"
    </code></pre>
    <p>üìå <strong>Uso comum de <code>static</code></strong></p>
    <ul>
        <li>Criar <strong>constantes globais</strong> (<code>Math.PI</code>, <code>Date.now()</code>).</li>
        <li>M√©todos auxiliares que <strong>n√£o dependem de inst√¢ncias</strong>.</li>
    </ul>

    <hr>

    <h2>4.4 Getters e Setters</h2>

    <p><strong>Getters (<code>get</code>)</strong> e <strong>setters (<code>set</code>)</strong> s√£o usados para acessar e modificar propriedades <strong>de forma controlada</strong>.</p>

    <h3>Exemplo</h3>
    <pre><code>
class Produto {
  private _preco: number;

  constructor(preco: number) {
    this._preco = preco;
  }

  get preco(): number {
    return this._preco;
  }

  set preco(valor: number) {
    if (valor <= 0) {
      console.log("O pre√ßo deve ser maior que zero!");
      return;
    }
    this._preco = valor;
  }
}

const p = new Produto(100);
console.log(p.preco); // Usa o getter -> 100

p.preco = 150; // Usa o setter
console.log(p.preco); // 150

p.preco = -50; // "O pre√ßo deve ser maior que zero!"
    </code></pre>
    <p>üìå <strong>Vantagens dos Getters e Setters</strong></p>
    <ul>
        <li>Protegem a modifica√ß√£o de dados.</li>
        <li>Permitem l√≥gica adicional ao acessar/modificar propriedades.</li>
        <li>Mant√™m a <strong>encapsula√ß√£o</strong> dos dados internos.</li>
    </ul>

    <hr>

    <h2>Resumo</h2>

    <table>
        <thead>
            <tr>
                <th>Conceito</th>
                <th>Descri√ß√£o</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Classes</strong></td>
                <td>Definem modelos para criar objetos</td>
            </tr>
            <tr>
                <td><strong>Modificadores</strong></td>
                <td><code>public</code> (acess√≠vel em qualquer lugar), <code>private</code> (somente dentro da classe), <code>protected</code> (acess√≠vel em subclasses)</td>
            </tr>
            <tr>
                <td><strong>Heran√ßa</strong></td>
                <td><code>extends</code> permite herdar propriedades e m√©todos</td>
            </tr>
            <tr>
                <td><strong>Interfaces</strong></td>
                <td><code>implements</code> define um contrato que a classe deve seguir</td>
            </tr>
            <tr>
                <td><strong>M√©todos Est√°ticos</strong></td>
                <td><code>static</code> permite m√©todos e propriedades sem precisar criar inst√¢ncia</td>
            </tr>
            <tr>
                <td><strong>Getters/Setters</strong></td>
                <td>M√©todos especiais para acessar/modificar propriedades com valida√ß√£o</td>
            </tr>
        </tbody>
    </table>

    <hr>

    <h2>Conclus√£o</h2>

    <p>A Orienta√ß√£o a Objetos no TypeScript oferece <strong>encapsulamento, reutiliza√ß√£o de c√≥digo e organiza√ß√£o</strong>. üöÄ</p>


    <h1>5. Manipula√ß√£o de C√≥digo no TypeScript</h1>

    <hr>

    <h2>5.1 Namespaces e M√≥dulos (<code>import/export</code>)</h2>

    <h3>Namespaces</h3>
    <p>Os <strong>namespaces</strong> eram usados no TypeScript para <strong>organizar o c√≥digo e evitar conflitos de nomes</strong> em projetos grandes. Hoje, <strong>m√≥dulos s√£o mais recomendados</strong>, mas namespaces ainda podem ser √∫teis em certos cen√°rios.</p>

    <p>üìå <strong>Exemplo de Namespace</strong></p>
    <pre><code>
namespace Utils {
  export function saudacao(nome: string): string {
    return `Ol√°, ${nome}!`;
  }

  export const versao = "1.0";
}

console.log(Utils.saudacao("Alice"));
console.log(Utils.versao);
    </code></pre>
    <ul>
        <li>A palavra-chave <code>export</code> torna a fun√ß√£o e a constante acess√≠veis fora do namespace.</li>
        <li>Para acessar os membros do namespace, usamos <code>Utils.saudacao()</code> e <code>Utils.versao</code>.</li>
    </ul>
    <p>‚ö† <strong>Nota:</strong> Namespaces <strong>n√£o s√£o mais recomendados</strong> para projetos modernos, pois os m√≥dulos (<code>import/export</code>) s√£o mais poderosos e escal√°veis.</p>

    <h3>M√≥dulos (<code>import/export</code>)</h3>
    <p>Os <strong>m√≥dulos</strong> permitem dividir o c√≥digo em arquivos reutiliz√°veis e organizados.</p>

    <p>üìå <strong>Exemplo de M√≥dulo</strong></p>
    <p>Criamos dois arquivos:</p>

    <p>üìå <strong>Arquivo: <code>utils.ts</code> (m√≥dulo exportador)</strong></p>
    <pre><code>
export function saudacao(nome: string): string {
  return `Ol√°, ${nome}!`;
}

export const versao = "1.0";
    </code></pre>

    <p>üìå <strong>Arquivo: <code>main.ts</code> (m√≥dulo importador)</strong></p>
    <pre><code>
import { saudacao, versao } from "./utils";

console.log(saudacao("Alice"));
console.log(versao);
    </code></pre>

    <p>‚úÖ <strong>Vantagens dos m√≥dulos (<code>import/export</code>)</strong></p>
    <ul>
        <li>Melhor suporte em projetos grandes.</li>
        <li>Permite importar apenas o que √© necess√°rio.</li>
        <li>Funciona nativamente no ES6+ e em ferramentas como Webpack e Node.js.</li>
    </ul>

    <hr>

    <h2>5.2 Decorators (Metaprograma√ß√£o)</h2>

    <p>Os <strong>Decorators</strong> s√£o um recurso avan√ßado do TypeScript para <strong>modificar classes, m√©todos, propriedades e par√¢metros</strong> em tempo de execu√ß√£o.</p>

    <p>üìå <strong>‚ö† Importante:</strong></p>
    <ul>
        <li>Decorators precisam que o <strong><code>experimentalDecorators</code> esteja ativado</strong> no <code>tsconfig.json</code>.</li>
        <li>S√£o muito usados em frameworks como <strong>Angular</strong> e bibliotecas como <strong>TypeORM</strong>.</li>
    </ul>

    <h3>Exemplo de Decorator de Classe</h3>
    <p>Criamos um <strong>decorator</strong> que adiciona um log quando uma classe √© instanciada.</p>
    <pre><code>
function LogarInstancia(construtor: Function) {
  console.log(`Classe ${construtor.name} foi instanciada.`);
}

@LogarInstancia
class Pessoa {
  constructor(public nome: string) {}
}

const p = new Pessoa("Carlos"); // "Classe Pessoa foi instanciada."
    </code></pre>
    <p>üìå <strong>Explica√ß√£o:</strong></p>
    <ul>
        <li><code>@LogarInstancia</code> √© um <strong>decorator de classe</strong> que executa c√≥digo quando a classe √© carregada.</li>
    </ul>

    <h3>Exemplo de Decorator de M√©todo</h3>
    <p>Criamos um <strong>decorator que registra chamadas de m√©todos</strong>.</p>
    <pre><code>
function LogarMetodo(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const metodoOriginal = descriptor.value;

  descriptor.value = function (...args: any[]) {
    console.log(`Chamando m√©todo ${propertyKey} com argumentos:`, args);
    return metodoOriginal.apply(this, args);
  };
}

class Calculadora {
  @LogarMetodo
  somar(a: number, b: number): number {
    return a + b;
  }
}

const calc = new Calculadora();
console.log(calc.somar(2, 3)); // "Chamando m√©todo somar com argumentos: [2,3]"
    </code></pre>
    <p>üìå <strong>Explica√ß√£o:</strong></p>
    <ul>
        <li><code>@LogarMetodo</code> intercepta chamadas do m√©todo <code>somar()</code>, registrando seus par√¢metros.</li>
    </ul>

    <h3>Exemplo de Decorator de Propriedade</h3>
    <p>Criamos um <strong>decorator que valida se um valor √© positivo</strong>.</p>
    <pre><code>
function ValidaNumero(target: any, propertyKey: string) {
  let valor: number;

  Object.defineProperty(target, propertyKey, {
    get: () => valor,
    set: (novoValor: number) => {
      if (novoValor < 0) {
        throw new Error("O valor n√£o pode ser negativo!");
      }
      valor = novoValor;
    }
  });
}

class Conta {
  @ValidaNumero
  saldo!: number;
}

const conta = new Conta();
conta.saldo = 100;
console.log(conta.saldo); // 100

// conta.saldo = -50; // ‚ùå Erro: "O valor n√£o pode ser negativo!"
    </code></pre>
    <p>üìå <strong>Explica√ß√£o:</strong></p>
    <ul>
        <li>O <strong>getter/setter personalizado</strong> impede que <code>saldo</code> receba valores negativos.</li>
    </ul>

    <p>‚úÖ <strong>Onde os Decorators s√£o usados?</strong></p>
    <ul>
        <li><strong>Frameworks como Angular</strong> (<code>@Component</code>, <code>@Injectable</code>).</li>
        <li><strong>ORMs como TypeORM</strong> (<code>@Entity</code>, <code>@Column</code>).</li>
        <li><strong>Valida√ß√£o de entrada de dados</strong>.</li>
    </ul>

    <hr>

    <h2>5.3 Tipagem Estrutural</h2>

    <p>O <strong>TypeScript usa "tipagem estrutural" ao inv√©s de tipagem nominal</strong>. Isso significa que <strong>o que importa n√£o √© o nome do tipo, mas sua estrutura</strong>.</p>

    <p>üìå <strong>Exemplo de Tipagem Estrutural</strong></p>
    <pre><code>
class Carro {
  modelo: string;
  ano: number;

  constructor(modelo: string, ano: number) {
    this.modelo = modelo;
    this.ano = ano;
  }
}

interface Veiculo {
  modelo: string;
  ano: number;
}

let meuCarro: Veiculo = new Carro("Fusca", 1970);
    </code></pre>
    <p>üìå <strong>Explica√ß√£o:</strong></p>
    <ul>
        <li>O objeto <code>meuCarro</code> √© da <strong>interface <code>Veiculo</code></strong>, mas recebe um objeto da classe <code>Carro</code>.</li>
        <li>Isso <strong>funciona porque as estruturas s√£o compat√≠veis</strong> (mesmos atributos).</li>
    </ul>

    <p>‚úÖ <strong>Vantagens da Tipagem Estrutural</strong></p>
    <ul>
        <li>Maior flexibilidade no uso de objetos.</li>
        <li>Facilita o uso de diferentes classes que tenham a mesma estrutura.</li>
    </ul>

    <hr>

    <h2>Resumo</h2>

    <table>
        <thead>
            <tr>
                <th>Conceito</th>
                <th>Descri√ß√£o</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Namespaces</strong></td>
                <td>Organiza√ß√£o de c√≥digo (n√£o recomendados para novos projetos)</td>
            </tr>
            <tr>
                <td><strong>M√≥dulos</strong></td>
                <td><code>import/export</code> para dividir c√≥digo em arquivos reutiliz√°veis</td>
            </tr>
            <tr>
                <td><strong>Decorators</strong></td>
                <td>Metaprograma√ß√£o para modificar classes, m√©todos e propriedades</td>
            </tr>
            <tr>
                <td><strong>Tipagem Estrutural</strong></td>
                <td>Compara√ß√£o de tipos baseada na estrutura e n√£o no nome</td>
            </tr>
        </tbody>
    </table>

    <hr>

    <h2>Conclus√£o</h2>

    <p>A <strong>manipula√ß√£o de c√≥digo no TypeScript</strong> ajuda a criar c√≥digo <strong>mais organizado, reutiliz√°vel e din√¢mico</strong>. üöÄ</p>


    <h1>6. Ferramentas e Configura√ß√£o do TypeScript</h1>

    <p>O TypeScript oferece um ecossistema robusto com v√°rias ferramentas essenciais para desenvolvimento profissional. Aqui est√£o os tr√™s pilares fundamentais:</p>
    <ol>
        <li><strong><code>tsconfig.json</code></strong> ‚Äì Configura√ß√£o do compilador TypeScript.</li>
        <li><strong><code>tsc</code> (TypeScript Compiler)</strong> ‚Äì Transpila TypeScript para JavaScript.</li>
        <li><strong>Linting e Formata√ß√£o (ESLint, Prettier)</strong> ‚Äì Mant√©m o c√≥digo limpo e padronizado.</li>
    </ol>

    <hr>

    <h2>6.1 <code>tsconfig.json</code> (Configura√ß√£o do Compilador)</h2>

    <p>O arquivo <code>tsconfig.json</code> √© a <strong>configura√ß√£o central</strong> do TypeScript. Ele define <strong>como o c√≥digo ser√° compilado</strong> e quais regras ser√£o aplicadas.</p>

    <p>üìå <strong>Criando um <code>tsconfig.json</code></strong></p>
    <p>Execute no terminal:</p>
    <pre><code>
tsc --init
    </code></pre>
    <p>Isso gera um arquivo <code>tsconfig.json</code> com v√°rias configura√ß√µes comentadas.</p>

    <p>üìå <strong>Exemplo de <code>tsconfig.json</code> B√°sico</strong></p>
    <pre><code>
{
  "compilerOptions": {
    "target": "ES6",
    "module": "CommonJS",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "noImplicitAny": true,
    "esModuleInterop": true
  },
  "include": ["src"],
  "exclude": ["node_modules"]
}
    </code></pre>

    <p>üîç <strong>Explica√ß√£o das principais op√ß√µes:</strong></p>
    <ul>
        <li><code>"target": "ES6"</code> ‚Üí Compila TypeScript para JavaScript ES6.</li>
        <li><code>"module": "CommonJS"</code> ‚Üí Usa m√≥dulos no estilo Node.js.</li>
        <li><code>"outDir": "./dist"</code> ‚Üí Define a pasta onde o c√≥digo compilado ser√° salvo.</li>
        <li><code>"rootDir": "./src"</code> ‚Üí Define a pasta onde o c√≥digo TypeScript est√° localizado.</li>
        <li><code>"strict": true</code> ‚Üí Ativa verifica√ß√µes rigorosas de tipo.</li>
        <li><code>"noImplicitAny": true</code> ‚Üí Evita vari√°veis sem tipo expl√≠cito.</li>
        <li><code>"esModuleInterop": true</code> ‚Üí Permite importa√ß√µes de m√≥dulos ES6.</li>
        <li><code>"include": ["src"]</code> ‚Üí Compila apenas arquivos dentro da pasta <code>src</code>.</li>
        <li><code>"exclude": ["node_modules"]</code> ‚Üí Exclui <code>node_modules</code> da compila√ß√£o.</li>
    </ul>

    <p>‚úÖ <strong>Personalizando o <code>tsconfig.json</code></strong></p>
    <p>Se estiver usando <strong>React</strong>, altere <code>"module"</code> para <code>"ESNext"</code> e <code>"jsx"</code> para <code>"react"</code>.</p>
    <pre><code>
{
  "compilerOptions": {
    "module": "ESNext",
    "jsx": "react"
  }
}
    </code></pre>

    <hr>

    <h2>6.2 <code>tsc</code> (Compilador TypeScript)</h2>

    <p>O <strong>TypeScript Compiler (<code>tsc</code>)</strong> √© a ferramenta que <strong>converte TypeScript em JavaScript</strong>.</p>

    <p>üìå <strong>Compilar um arquivo manualmente</strong></p>
    <pre><code>
tsc meuArquivo.ts
    </code></pre>
    <p>Isso gera um <strong><code>meuArquivo.js</code></strong> com o c√≥digo JavaScript equivalente.</p>

    <p>üìå <strong>Compilar todo o projeto baseado no <code>tsconfig.json</code></strong></p>
    <pre><code>
tsc
    </code></pre>
    <p>Isso compila todos os arquivos <code>.ts</code> conforme definido no <code>tsconfig.json</code>.</p>

    <p>üìå <strong>Compilar e assistir mudan√ßas automaticamente</strong></p>
    <pre><code>
tsc --watch
    </code></pre>
    <p>Isso recompila automaticamente os arquivos ao serem alterados.</p>

    <hr>

    <h2>6.3 ESLint e Prettier (Linting e Formata√ß√£o)</h2>

    <h3>ESLint (An√°lise de C√≥digo Est√°tico)</h3>
    <p>O <strong>ESLint</strong> ajuda a identificar <strong>erros e padr√µes ruins</strong> no c√≥digo.</p>

    <p>üìå <strong>Instalando o ESLint no projeto</strong></p>
    <pre><code>
npm install --save-dev eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin
    </code></pre>

    <p>üìå <strong>Criando um arquivo de configura√ß√£o <code>.eslintrc.json</code></strong></p>
    <pre><code>
{
  "parser": "@typescript-eslint/parser",
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended"
  ],
  "rules": {
    "semi": ["error", "always"],
    "quotes": ["error", "double"],
    "@typescript-eslint/no-explicit-any": "warn"
  }
}
    </code></pre>

    <p>üìå <strong>Rodando o ESLint no c√≥digo</strong></p>
    <pre><code>
npx eslint src/**/*.ts
    </code></pre>

    <h3>Prettier (Formata√ß√£o de C√≥digo)</h3>
    <p>O <strong>Prettier</strong> formata o c√≥digo automaticamente. Ele √© √∫til junto com o ESLint.</p>

    <p>üìå <strong>Instalando o Prettier</strong></p>
    <pre><code>
npm install --save-dev prettier eslint-config-prettier eslint-plugin-prettier
    </code></pre>

    <p>üìå <strong>Criando um arquivo de configura√ß√£o <code>.prettierrc</code></strong></p>
    <pre><code>
{
  "semi": true,
  "singleQuote": false,
  "tabWidth": 2
}
    </code></pre>

    <p>üìå <strong>Formatando c√≥digo com Prettier</strong></p>
    <pre><code>
npx prettier --write src/**/*.ts
    </code></pre>

    <hr>

    <h2>Resumo</h2>

    <table>
        <thead>
            <tr>
                <th>Ferramenta</th>
                <th>Fun√ß√£o</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong><code>tsconfig.json</code></strong></td>
                <td>Configura√ß√£o do compilador TypeScript</td>
            </tr>
            <tr>
                <td><strong><code>tsc</code> (TypeScript Compiler)</strong></td>
                <td>Transpila c√≥digo TypeScript para JavaScript</td>
            </tr>
            <tr>
                <td><strong>ESLint</strong></td>
                <td>Detecta erros e melhora a qualidade do c√≥digo</td>
            </tr>
            <tr>
                <td><strong>Prettier</strong></td>
                <td>Formata o c√≥digo automaticamente</td>
            </tr>
        </tbody>
    </table>

    <hr>

    <h2>Conclus√£o</h2>

    <p>Com essas ferramentas, voc√™ garante que seu projeto TypeScript seja <strong>bem configurado, compilado corretamente e siga padr√µes de qualidade</strong>. üöÄ</p>

    <h1>7. Integra√ß√£o com Frameworks no TypeScript</h1>

    <hr>

    <h2>7.1 TypeScript com Node.js</h2>

    <p>O <strong>Node.js</strong> √© uma plataforma para execu√ß√£o de JavaScript no backend. O TypeScript funciona com o Node.js, mas como o Node n√£o entende TypeScript diretamente, precisamos de:</p>
    <ol>
        <li><strong>Compilar TypeScript para JavaScript</strong> usando <code>tsc</code>.</li>
        <li><strong>Adicionar as tipagens do Node.js</strong> com <code>@types/node</code>.</li>
    </ol>

    <h3>Configurando um projeto TypeScript no Node.js</h3>

    <p>üìå <strong>1. Criar um novo projeto</strong></p>
    <pre><code>
mkdir meu-projeto-node && cd meu-projeto-node
npm init -y
    </code></pre>

    <p>üìå <strong>2. Instalar o TypeScript e as tipagens do Node.js</strong></p>
    <pre><code>
npm install --save-dev typescript ts-node @types/node
    </code></pre>

    <p>üìå <strong>3. Criar um <code>tsconfig.json</code></strong></p>
    <pre><code>
tsc --init
    </code></pre>

    <p>üìå <strong>4. Criar um arquivo <code>server.ts</code></strong></p>
    <pre><code>
import http from "http";

const server = http.createServer((req, res) => {
  res.writeHead(200, { "Content-Type": "text/plain" });
  res.end("Ol√°, TypeScript com Node.js!");
});

server.listen(3000, () => console.log("Servidor rodando em http://localhost:3000"));
    </code></pre>

    <p>üìå <strong>5. Executar o servidor com <code>ts-node</code></strong></p>
    <pre><code>
npx ts-node server.ts
    </code></pre>

    <p>‚úÖ <strong>Destaques:</strong></p>
    <ul>
        <li><code>@types/node</code> fornece <strong>tipagens para as APIs do Node.js</strong>.</li>
        <li><code>ts-node</code> permite <strong>executar TypeScript diretamente</strong>, sem precisar compilar antes.</li>
    </ul>

    <hr>

    <h2>7.2 TypeScript com React</h2>

    <p>O React tem <strong>suporte nativo ao TypeScript</strong>, usando arquivos <strong><code>.tsx</code></strong> para tipagem de componentes.</p>

    <h3>Criando um projeto React com TypeScript</h3>

    <p>üìå <strong>1. Criar um novo projeto React com TypeScript</strong></p>
    <pre><code>
npx create-react-app meu-app --template typescript
    </code></pre>

    <p>üìå <strong>2. Criar um componente com tipagem (<code>App.tsx</code>)</strong></p>
    <pre><code>
import React from "react";

type Props = {
  nome: string;
};

const Saudacao: React.FC&lt;Props&gt; = ({ nome }) => {
  return &lt;h1&gt;Ol√°, {nome}!&lt;/h1&gt;;
};

const App: React.FC = () => {
  return &lt;Saudacao nome="Alice" /&gt;;
};

export default App;
    </code></pre>

    <p>‚úÖ <strong>Destaques:</strong></p>
    <ul>
        <li>O <strong><code>React.FC&lt;T&gt;</code></strong> define que <code>Saudacao</code> √© um <strong>componente funcional com props tipadas</strong>.</li>
        <li>O <code>nome</code> tem <strong>tipagem expl√≠cita (<code>string</code>)</strong>, reduzindo erros.</li>
    </ul>

    <h3>Tipagem de Estados e Eventos no React</h3>

    <p>üìå <strong>Gerenciando estado com <code>useState</code></strong></p>
    <pre><code>
import React, { useState } from "react";

const Contador: React.FC = () => {
  const [contador, setContador] = useState&lt;number&gt;(0);

  return (
    &lt;div&gt;
      &lt;p&gt;Valor: {contador}&lt;/p&gt;
      &lt;button onClick={() => setContador(contador + 1)}&gt;Incrementar&lt;/button&gt;
    &lt;/div&gt;
  );
};

export default Contador;
    </code></pre>

    <p>üìå <strong>Tipagem de eventos (<code>onChange</code>, <code>onClick</code>)</strong></p>
    <pre><code>
const InputTexto: React.FC = () => {
  const [texto, setTexto] = useState&lt;string&gt;("");

  const handleChange = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
    setTexto(event.target.value);
  };

  return &lt;input type="text" value={texto} onChange={handleChange} /&gt;;
};
    </code></pre>

    <p>‚úÖ <strong>Destaques:</strong></p>
    <ul>
        <li><code>useState&lt;number&gt;(0)</code> ‚Üí Garante que o estado s√≥ aceite <strong>n√∫meros</strong>.</li>
        <li><code>onChange={handleChange}</code> ‚Üí <code>handleChange</code> recebe um evento <strong>tipado corretamente</strong> (<code>ChangeEvent&lt;HTMLInputElement&gt;</code>).</li>
    </ul>

    <hr>

    <h2>7.3 TypeScript com Angular</h2>

    <p>O <strong>Angular</strong> foi criado pelo Google e tem <strong>suporte nativo ao TypeScript</strong>. Na verdade, <strong>o Angular usa TypeScript como linguagem principal</strong>.</p>

    <h3>Criando um projeto Angular com TypeScript</h3>

    <p>üìå <strong>1. Instalar o Angular CLI</strong></p>
    <pre><code>
npm install -g @angular/cli
    </code></pre>

    <p>üìå <strong>2. Criar um novo projeto Angular</strong></p>
    <pre><code>
ng new meu-app-angular
cd meu-app-angular
ng serve
    </code></pre>

    <p>‚úÖ O Angular j√° usa TypeScript por padr√£o, ent√£o n√£o √© necess√°rio configur√°-lo manualmente.</p>

    <h3>Tipagem no Angular</h3>

    <p>üìå <strong>Criando um <code>Component</code> com tipagem (<code>app.component.ts</code>)</strong></p>
    <pre><code>
import { Component } from "@angular/core";

@Component({
  selector: "app-root",
  template: "&lt;h1&gt;Ol√°, {{ nome }}&lt;/h1&gt;",
})
export class AppComponent {
  nome: string = "Mundo";
}
    </code></pre>

    <p>üìå <strong>Tipando um servi√ßo (<code>usuario.service.ts</code>)</strong></p>
    <pre><code>
import { Injectable } from "@angular/core";

interface Usuario {
  id: number;
  nome: string;
}

@Injectable({
  providedIn: "root",
})
export class UsuarioService {
  private usuarios: Usuario[] = [
    { id: 1, nome: "Alice" },
    { id: 2, nome: "Bob" },
  ];

  getUsuarios(): Usuario[] {
    return this.usuarios;
  }
}
    </code></pre>

    <p>‚úÖ <strong>Destaques:</strong></p>
    <ul>
        <li><code>@Component()</code> ‚Üí Define um <strong>componente Angular</strong>.</li>
        <li><code>@Injectable()</code> ‚Üí Define um <strong>servi√ßo Angular</strong>.</li>
        <li>A interface <code>Usuario</code> melhora a seguran√ßa do c√≥digo.</li>
    </ul>

    <hr>

    <h2>Compara√ß√£o entre Node.js, React e Angular com TypeScript</h2>

    <table>
        <thead>
            <tr>
                <th>Framework</th>
                <th>Integra√ß√£o com TypeScript</th>
                <th>Exemplo de uso</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Node.js</strong></td>
                <td>Usa <code>@types/node</code> para APIs</td>
                <td>Servidor HTTP, APIs REST</td>
            </tr>
            <tr>
                <td><strong>React</strong></td>
                <td>Usa <code>.tsx</code>, <code>React.FC&lt;T&gt;</code></td>
                <td>Componentes, hooks, eventos</td>
            </tr>
            <tr>
                <td><strong>Angular</strong></td>
                <td><strong>Baseado 100% em TypeScript</strong></td>
                <td>Componentes, servi√ßos, inje√ß√£o de depend√™ncias</td>
            </tr>
        </tbody>
    </table>

    <hr>

    <h2>Conclus√£o</h2>

    <p>O <strong>TypeScript traz grandes benef√≠cios</strong> ao trabalhar com frameworks modernos:</p>
    <ul>
        <li><strong>Node.js</strong>: Tipagem para APIs e maior seguran√ßa no backend.</li>
        <li><strong>React</strong>: Melhor suporte a componentes e eventos com <code>.tsx</code>.</li>
        <li><strong>Angular</strong>: Integra√ß√£o total, pois √© constru√≠do sobre TypeScript.</li>
    </ul>

</code></pre>
<hr>
<h1>Aprenda um CRUD</h1>

<p>Aqui est√° um exemplo de um CRUD simples para cadastrar alunos:</p>

<h2>HTML</h2>
<pre><code>
&lt;!DOCTYPE html&gt;
&lt;html lang="pt-br"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
&lt;title&gt;Document&lt;/title&gt;
&lt;link rel="stylesheet" href="style.css"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt; Crud para cadastrar anluos&lt;/h1&gt;

&lt;form id="aluno-form"&gt;
    &lt;input type="text" id="nome" placeholder="nome do aluno" required&gt;
    &lt;button type="submit"&gt;Adicionar aluno&lt;/button&gt;
&lt;/form&gt;

&lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Nome&lt;/th&gt;
            &lt;th&gt;A√ß√£o&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody id="alunos-tabela"&gt;
        &lt;!--os dados ser√£o inseridos aqui--&gt;

    &lt;/tbody&gt;
&lt;/table&gt;




&lt;script src="script.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h2>CSS</h2>
<pre><code>
/* Reset b√°sico */
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}

body {
font-family: 'Arial', sans-serif;
background-color: #f9f9f9;
color: #333;
display: flex;
flex-direction: column;
align-items: center;
padding: 20px;
}

h1 {
color: #333;
margin-bottom: 20px;
}

form {
display: flex;
gap: 10px;
margin-bottom: 20px;
}

input[type="text"] {
padding: 10px;
border: 1px solid #ccc;
border-radius: 5px;
width: 200px;
}

button {
padding: 10px 15px;
border: none;
background-color: #000000;
color: white;
border-radius: 5px;
cursor: pointer;
transition: background-color 0.3s;
}

button:hover {
background-color: #6b6b6b;
}

table {
width: 80%;
max-width: 600px;
border-collapse: collapse;
margin-top: 10px;
}

thead {
background-color: #000000;
color: white;
}

th, td {
padding: 12px;
text-align: left;
border-bottom: 1px solid #ddd;
}

tr:nth-child(even) {
background-color: #f2f2f2;
}

td button {
padding: 5px 10px;
font-size: 14px;
background-color: #28a745;
border: none;
color: white;
border-radius: 3px;
cursor: pointer;
transition: background-color 0.3s;
}

td button:nth-child(2) {
background-color: #dc3545;
}

td button:hover {
opacity: 0.8;
}
</code></pre>

<h2>JavaScript</h2>
<pre><code>
const formulario = document.getElementById ("aluno-form");
const tabela = document.getElementById("alunos-tabela");

let alunos = []; // Armazena os dados dos alunos

formulario.addEventListener("submit", (evento)=> {
evento.preventDefault();

const nomeInput = document.getElementById("nome");
const nomeAluno = nomeInput.value.trim();

if(nomeAluno){
    // Adicionar o aluno na lista e renderizar
    adicionarAluno(nomeAluno);
    nomeInput.value = ""; // Limpa o campo ap√≥s adicionar
}
});

function adicionarAluno(nome) {
const novoAluno = {id: Date.now(), nome: nome}; // cria o aluno com ID unico
alunos.push(novoAluno);
atualizarTabela();
}

function atualizarTabela(){
tabela.innerHTML = ""; // Limpa a tabela antes de renderizar

alunos.forEach(aluno => {
    const linha = document.createElement("tr");

    linha.innerHTML = `
    &lt;td&gt;${aluno.nome}&lt;/td&gt;
    &lt;td&gt;
        &lt;button onclick="editarAluno(${aluno.id})"&gt;Editar&lt;/button&gt;
        &lt;button onclick="deletarAluno(${aluno.id})"&gt;Excluir&lt;/button&gt;
    &lt;/td&gt;
    `;
    tabela.appendChild(linha);
});
}

function editarAluno(id){
const aluno = alunos.find(aluno => aluno.id === id);

if(aluno){
    const novoNome = prompt("Digite o novo nome do aluno", aluno.nome);

    if(novoNome && novoNome.trim() !== ""){
        aluno.nome = novoNome.trim();
        atualizarTabela();
    }
}
}

function deletarAluno(id){
alunos = alunos.filter(aluno => aluno.id !== id);
atualizarTabela();
}
</section>
</code></pre>
        </section>
    </main>

    <!-- Rodap√© -->
    <footer class="site-footer">
        <p>&copy; 2025 Pcpropr.</p>
    </footer>
</body>
</html>